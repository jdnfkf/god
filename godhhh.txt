loadstring([[
-- 手机端通用超强生存脚本（终极修复版）
-- 作者：手机端生存专家
-- 版本：5.0 修复死亡报错问题

-- ==================== 全局服务初始化 ====================
local PlayerService = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DebrisService = game:GetService("Debris")
local ScriptContext = game:GetService("ScriptContext")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local StarterPlayer = game:GetService("StarterPlayer")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")
local TextService = game:GetService("TextService")
local CollectionService = game:GetService("CollectionService")
local SoundService = game:GetService("SoundService")
local PhysicsService = game:GetService("PhysicsService")
local PathfindingService = game:GetService("PathfindingService")
local Teams = game:GetService("Teams")
local MarketplaceService = game:GetService("MarketplaceService")
local GroupService = game:GetService("GroupService")
local BadgeService = game:GetService("BadgeService")
local PointsService = game:GetService("PointsService")
local AnalyticsService = game:GetService("AnalyticsService")
local Chat = game:GetService("Chat")
local VoiceChatService = game:GetService("VoiceChatService")
local NetworkClient = game:GetService("NetworkClient")
local MaterialService = game:GetService("MaterialService")
local TestService = game:GetService("TestService")
local ChangeHistoryService = game:GetService("ChangeHistoryService")
local Selection = game:GetService("Selection")
local StudioService = game:GetService("StudioService")
local CoreGui = game:GetService("CoreGui")
local CorePackages = game:GetService("CorePackages")
local RobloxReplicatedStorage = game:GetService("RobloxReplicatedStorage")
local SocialService = game:GetService("SocialService")
local LocalizationService = game:GetService("LocalizationService")
local GuiService = game:GetService("GuiService")
local HapticService = game:GetService("HapticService")
local VRService = game:GetService("VRService")
local RenderSettings = game:GetService("RenderSettings")
local Stats = game:GetService("Stats")
local ScriptEditorService = game:GetService("ScriptEditorService")
local NotificationService = game:GetService("NotificationService")
local PlayerEmulatorService = game:GetService("PlayerEmulatorService")

-- 获取本地玩家
local LocalPlayer = PlayerService.LocalPlayer
if not LocalPlayer then
    repeat wait() until PlayerService.LocalPlayer
    LocalPlayer = PlayerService.LocalPlayer
end

-- ==================== 核心配置参数 ====================
local CONFIG = {
    -- 回血系统
    HEAL_MULTIPLIER = 9, -- 9倍自动回血
    HEAL_BASE_RATE = 0.018, -- 基础回血率1.8%/秒
    EMERGENCY_HEAL_THRESHOLD = 0.30, -- 紧急回血阈值
    EMERGENCY_HEAL_BOOST = 2.5, -- 紧急回血额外倍率
    HEALTH_CAP = math.huge, -- 生命值上限
    
    -- 重生系统
    RESPAWN_DELAY = 0.01, -- 重生延迟
    RESPAWN_POSITION_OFFSET = Vector3.new(0, 5, 0), -- 重生位置偏移
    RESPAWN_POSITION_MEMORY = 25, -- 位置记忆数量
    FORCE_RESPAWN_ATTEMPTS = 8, -- 强制重生尝试次数
    RESPAWN_ERROR_RETRY = 3, -- 重生错误重试
    
    -- 抓取拦截系统
    GRAB_DETECTION_RADIUS = 35,
    GRAB_FORCE_THRESHOLD = 10000,
    ANTI_GRAB_PUSH_FORCE = 30,
    ANTI_GRAB_TELEPORT_DISTANCE = 15,
    ANTI_GRAB_COOLDOWN = 0.05,
    
    -- 突脸拦截系统
    WARP_DETECTION_THRESHOLD = 20,
    WARP_COOLDOWN = 0.06,
    WARP_SPEED_LIMIT = 150,
    WARP_TELEPORT_PROTECTION = true,
    
    -- 剧情杀拦截
    SCRIPTED_DEATH_PREVENTION = true,
    INSTANT_DEATH_BLOCK = true,
    HEALTH_LOCK_THRESHOLD = 0.2,
    
    -- 角色防销毁
    ANTI_DESTROY_ENABLED = true,
    CRITICAL_PARTS_PROTECTION = true,
    AUTO_PARTS_RECOVERY = true,
    CHARACTER_INTEGRITY_CHECK = 0.5, -- 完整性检查间隔
    
    -- 远程指令拦截
    REMOTE_BLOCK_ENABLED = true,
    REMOTE_DETECTION_DELAY = 0.1,
    REMOTE_FORCE_BLOCK = true,
    
    -- 观战破解
    SPECTATOR_BYPASS_ENABLED = true,
    CAMERA_CONTROL_ENFORCE = true,
    SPECTATOR_UI_DISABLE = true,
    
    -- 一命重生破解
    INFINITE_LIVES_ENABLED = true,
    RESPAWN_LIMIT_REMOVAL = true,
    DEATH_PENALTY_BYPASS = true,
    
    -- 性能优化
    MOBILE_OPTIMIZATION = true,
    CONNECTION_CLEANUP_INTERVAL = 30,
    MEMORY_USAGE_LIMIT = 250,
    ERROR_RECOVERY_ENABLED = true,
    
    -- 报错修复
    ERROR_HANDLING_ENHANCED = true,
    NULL_REFERENCE_FIX = true,
    STACK_OVERFLOW_PROTECTION = true,
    
    -- 关键词列表
    SCRIPTED_DEATH_KEYWORDS = {
        "Kill", "Death", "Die", "Dead", "Execute", "Murder",
        "ScriptedDeath", "StoryKill", "OneShot", "InstaKill",
        "AdminKill", "ForceDeath", "RemoteKill", "PlotDeath",
        "Slay", "Destroy", "Terminate", "Eliminate", "Annihilate",
        "Obliterate", "Exterminate", "Massacre", "Assassinate",
        "Sacrifice", "Suicide", "Homicide", "Genocide"
    },
    
    REMOTE_BLOCK_KEYWORDS = {
        "Kill", "Death", "Destroy", "Explode", "Execute",
        "ForceKill", "ScriptedDeath", "StoryKill", "OneShot",
        "Instakill", "RemoteKill", "AdminKill", "SystemKill",
        "Murder", "Terminate", "Delete", "Remove", "DeletePlayer",
        "PlayerKill", "CharacterKill", "HumanoidKill", "DamagePlayer",
        "Damage", "Hurt", "Injure", "Wound", "Crush"
    },
    
    SPECTATOR_KEYWORDS = {
        "Spectator", "Spectate", "Observer", "Ghost", "DeadCam",
        "CameraMode", "DeathCam", "FollowCam", "观战", "旁观",
        "观察者", "幽灵模式", "SpectatorMode", "ObserverMode",
        "GhostMode", "DeadCamera", "DeathCamera", "FollowCamera"
    },
    
    CRITICAL_BODY_PARTS = {
        "Head", "HumanoidRootPart", "Torso", "UpperTorso", 
        "LowerTorso", "Left Arm", "Right Arm", "Left Leg", "Right Leg",
        "LeftFoot", "RightFoot", "LeftHand", "RightHand", "Neck"
    },
    
    PROTECTED_SCRIPTS = {
        "HealthScript", "DamageScript", "DeathHandler",
        "RespawnScript", "SpectatorScript", "KillScript"
    }
}

-- ==================== 全局状态管理 ====================
local STATE = {
    Character = nil,
    Humanoid = nil,
    HumanoidRootPart = nil,
    
    IsInitialized = false,
    IsCharacterValid = false,
    IsRespawning = false,
    IsDead = false,
    IsLoading = false,
    
    DeathPositions = {},
    LastSafePosition = nil,
    LastValidCFrame = nil,
    LastValidHealth = 100,
    LastRespawnTime = 0,
    
    Connections = {
        Heal = {},
        AntiGrab = {},
        AntiWarp = {},
        AntiScriptedDeath = {},
        AntiDestroy = {},
        RemoteBlock = {},
        Respawn = {},
        Monitor = {},
        Utility = {},
        ErrorHandler = {},
        Protection = {}
    },
    
    BlockedRemotes = {},
    BlockedScripts = {},
    ProtectedInstances = {},
    ErrorLog = {},
    
    LastCleanupTime = tick(),
    ConnectionCount = 0,
    ErrorCount = 0,
    RespawnCount = 0
}

-- ==================== 高级安全工具库 ====================
local SafeTools = {}

-- 安全包装执行（防止报错）
function SafeTools.SafeExecute(func, errorMsg)
    local success, result = xpcall(func, function(err)
        local errStr = tostring(err)
        if CONFIG.ERROR_HANDLING_ENHANCED then
            table.insert(STATE.ErrorLog, {
                Time = tick(),
                Error = errStr,
                Message = errorMsg or "No error message"
            })
            
            while #STATE.ErrorLog > 100 do
                table.remove(STATE.ErrorLog, 1)
            end
        end
        return errStr
    end)
    
    return success, result
end

-- 安全获取实例（防nil错误）
function SafeTools.GetInstance(parent, name, className)
    if not parent or typeof(parent) ~= "Instance" then
        return nil
    end
    
    local function safeFind()
        if not parent:IsDescendantOf(game) then
            return nil
        end
        
        local instance = parent:FindFirstChild(name)
        if instance and (not className or instance:IsA(className)) then
            return instance
        end
        
        for _, child in ipairs(parent:GetChildren()) do
            if child.Name == name and (not className or child:IsA(className)) then
                return child
            end
        end
        
        return nil
    end
    
    local success, result = SafeTools.SafeExecute(safeFind, "GetInstance failed")
    return success and result or nil
end

-- 安全断开连接
function SafeTools.Disconnect(connection)
    if connection and typeof(connection) == "RBXScriptConnection" then
        SafeTools.SafeExecute(function()
            if connection.Connected then
                connection:Disconnect()
            end
        end, "Disconnect failed")
    end
end

-- 安全断开所有连接
function SafeTools.DisconnectAll(connections)
    if type(connections) == "table" then
        for _, conn in ipairs(connections) do
            SafeTools.Disconnect(conn)
        end
        table.clear(connections)
    end
end

-- 字符串安全匹配
function SafeTools.StringMatch(str, patternList)
    if type(str) ~= "string" then return false end
    
    local lowerStr = string.lower(str)
    for _, pattern in ipairs(patternList) do
        if string.find(lowerStr, string.lower(pattern), 1, true) then
            return true
        end
    end
    return false
end

-- 强制设置存活状态（防死亡报错）
function SafeTools.ForceAlive(humanoid)
    if not humanoid or typeof(humanoid) ~= "Instance" then
        return false
    end
    
    return SafeTools.SafeExecute(function()
        -- 使用属性标记而不是直接修改
        humanoid:SetAttribute("IsDead", false)
        humanoid:SetAttribute("HealthState", "Alive")
        humanoid:SetAttribute("LastDeathTime", nil)
        
        -- 确保血量大于0
        if humanoid.Health <= 0 then
            humanoid.Health = math.max(1, humanoid.MaxHealth * 0.8)
        end
        
        -- 清除死亡标记
        if humanoid:GetAttribute("Died") then
            humanoid:SetAttribute("Died", false)
        end
        
        -- 设置重生标记
        humanoid:SetAttribute("JustRespawned", true)
        Delay(0.5, function()
            if humanoid then
                humanoid:SetAttribute("JustRespawned", false)
            end
        end)
        
        return true
    end, "ForceAlive failed") or false
end

-- 记录位置（防nil错误）
function SafeTools.RecordPosition(position)
    if not position or typeof(position) ~= "Vector3" then
        return
    end
    
    SafeTools.SafeExecute(function()
        table.insert(STATE.DeathPositions, {
            Position = position,
            Time = tick(),
            Index = #STATE.DeathPositions + 1
        })
        
        while #STATE.DeathPositions > CONFIG.RESPAWN_POSITION_MEMORY do
            table.remove(STATE.DeathPositions, 1)
        end
        
        STATE.LastSafePosition = position
        
        -- 备份到属性
        LocalPlayer:SetAttribute("LastDeathPos", position)
        LocalPlayer:SetAttribute("DeathPosCount", #STATE.DeathPositions)
    end, "RecordPosition failed")
end

-- 获取最近安全位置
function SafeTools.GetRecentPosition()
    if #STATE.DeathPositions > 0 then
        local lastPos = STATE.DeathPositions[#STATE.DeathPositions].Position
        if lastPos and typeof(lastPos) == "Vector3" then
            return lastPos
        end
    end
    
    if STATE.LastSafePosition and typeof(STATE.LastSafePosition) == "Vector3" then
        return STATE.LastSafePosition
    end
    
    return Vector3.new(0, 50, 0)
end

-- 安全设置属性
function SafeTools.SetProperty(instance, property, value)
    if not instance or typeof(instance) ~= "Instance" then
        return false
    end
    
    return SafeTools.SafeExecute(function()
        instance[property] = value
        return true
    end, "SetProperty failed: " .. tostring(property)) or false
end

-- 防nil调用
function SafeTools.SafeCall(func, ...)
    if not func or type(func) ~= "function" then
        return nil
    end
    
    return SafeTools.SafeExecute(function()
        return func(...)
    end, "SafeCall failed")
end

-- ==================== 9倍自动回血系统（防报错版）====================
local HealSystem = {}

function HealSystem.Initialize(humanoid)
    if not humanoid or typeof(humanoid) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.Heal)
    
    -- 计算回血参数
    local maxHealth = humanoid.MaxHealth
    local baseRate = maxHealth * CONFIG.HEAL_BASE_RATE
    local healPerSecond = baseRate * CONFIG.HEAL_MULTIPLIER
    
    -- 主回血循环
    local healConn = RunService.Heartbeat:Connect(function(dt)
        if not STATE.IsCharacterValid or not humanoid or not humanoid.Parent then
            return
        end
        
        SafeTools.SafeExecute(function()
            -- 防止nil引用
            if humanoid.Health <= 0 then
                return
            end
            
            -- 计算回血量
            local currentHealth = humanoid.Health
            local maxHealth = humanoid.MaxHealth
            
            if currentHealth >= maxHealth then
                return
            end
            
            local healAmount = healPerSecond * dt
            
            -- 紧急回血加成
            if currentHealth / maxHealth < CONFIG.EMERGENCY_HEAL_THRESHOLD then
                healAmount = healAmount * CONFIG.EMERGENCY_HEAL_BOOST
            end
            
            -- 应用回血
            local newHealth = currentHealth + healAmount
            newHealth = math.min(newHealth, maxHealth, CONFIG.HEALTH_CAP)
            
            -- 防止血量过低
            if newHealth < 1 then
                newHealth = math.max(1, maxHealth * 0.5)
            end
            
            humanoid.Health = newHealth
            STATE.LastValidHealth = newHealth
            
            -- 更新属性
            humanoid:SetAttribute("LastHealTime", tick())
            humanoid:SetAttribute("HealAmount", healAmount)
        end, "HealSystem loop error")
    end)
    
    table.insert(STATE.Connections.Heal, healConn)
    
    -- 血量监控
    local monitorConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        SafeTools.SafeExecute(function()
            if humanoid.Health <= 0 and STATE.IsCharacterValid then
                humanoid.Health = math.max(1, humanoid.MaxHealth * 0.6)
                SafeTools.ForceAlive(humanoid)
            end
        end, "Health monitor error")
    end)
    
    table.insert(STATE.Connections.Heal, monitorConn)
    
    -- 最大血量保护
    local maxHealthConn = humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
        SafeTools.SafeExecute(function()
            if humanoid.MaxHealth < 80 then
                humanoid.MaxHealth = 120
            end
        end, "MaxHealth protection error")
    end)
    
    table.insert(STATE.Connections.Heal, maxHealthConn)
    
    -- 手机触摸回血
    if CONFIG.MOBILE_OPTIMIZATION and UserInputService.TouchEnabled then
        local touchConn = UserInputService.TouchTap:Connect(function(touchPos, processed)
            if not processed and STATE.IsCharacterValid and humanoid then
                SafeTools.SafeExecute(function()
                    local currentHealth = humanoid.Health
                    local maxHealth = humanoid.MaxHealth
                    
                    if currentHealth < maxHealth * 0.8 then
                        local healBonus = maxHealth * 0.15
                        humanoid.Health = math.min(currentHealth + healBonus, maxHealth)
                        
                        -- 触觉反馈
                        if HapticService and HapticService:IsVibrationSupported(Enum.UserInputType.Touch) then
                            HapticService:SetMotor(Enum.UserInputType.Touch, Enum.VibrationMotor.Large, 0.5)
                        end
                    end
                end, "Touch heal error")
            end
        end)
        
        table.insert(STATE.Connections.Heal, touchConn)
    end
    
    -- 回血效果可视化
    local function CreateHealEffect()
        if not STATE.Character then return end
        
        SafeTools.SafeExecute(function()
            local healParticle = Instance.new("ParticleEmitter")
            healParticle.Name = "HealEffect"
            healParticle.Color = ColorSequence.new(Color3.fromRGB(0, 255, 0))
            healParticle.Size = NumberSequence.new(0.5)
            healParticle.Transparency = NumberSequence.new(0.5)
            healParticle.Lifetime = NumberRange.new(0.5)
            healParticle.Rate = 10
            healParticle.Speed = NumberRange.new(2)
            healParticle.Parent = STATE.Character:FindFirstChild("HumanoidRootPart") or STATE.Character
        end, "CreateHealEffect error")
    end
    
    -- 延迟创建效果
    Delay(1, CreateHealEffect)
end

-- ==================== 无限重生系统（死亡位置重生）====================
local RespawnSystem = {}

function RespawnSystem.Initialize(character)
    if not character or typeof(character) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.Respawn)
    
    local humanoid = SafeTools.GetInstance(character, "Humanoid", "Humanoid")
    if not humanoid then return end
    
    -- 记录初始位置
    local rootPart = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
    if rootPart then
        SafeTools.RecordPosition(rootPart.Position)
    end
    
    -- 破解重生限制
    SafeTools.SafeExecute(function()
        LocalPlayer:SetAttribute("CanRespawn", true)
        LocalPlayer:SetAttribute("RespawnLimit", math.huge)
        LocalPlayer:SetAttribute("OneLife", false)
        LocalPlayer:SetAttribute("NoRespawn", false)
        LocalPlayer:SetAttribute("InfiniteLives", true)
        LocalPlayer:SetAttribute("RespawnCount", 0)
        LocalPlayer:SetAttribute("LastDeathTime", nil)
        
        -- 破解游戏重生系统
        local respawnServices = {
            ReplicatedStorage:FindFirstChild("RespawnService"),
            Workspace:FindFirstChild("RespawnSystem"),
            game:GetService("ReplicatedFirst"):FindFirstChild("RespawnHandler")
        }
        
        for _, service in ipairs(respawnServices) do
            if service then
                service:SetAttribute("RespawnTime", 0)
                service:SetAttribute("RespawnDelay", 0)
                service:SetAttribute("MaxRespawns", math.huge)
            end
        end
    end, "Respawn limit bypass error")
    
    -- 死亡事件处理（修复报错）
    local diedConn = humanoid.Died:Connect(function()
        if STATE.IsRespawning or STATE.IsLoading then return end
        
        STATE.IsRespawning = true
        STATE.IsDead = true
        STATE.RespawnCount = STATE.RespawnCount + 1
        
        -- 记录死亡位置
        local deathRoot = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
        if deathRoot then
            SafeTools.RecordPosition(deathRoot.Position)
            STATE.LastRespawnTime = tick()
        end
        
        -- 死亡保护
        SafeTools.SafeExecute(function()
            -- 防止死亡报错
            humanoid:SetAttribute("Died", true)
            humanoid:SetAttribute("DeathTime", tick())
            
            -- 标记为待重生
            LocalPlayer:SetAttribute("NeedsRespawn", true)
            LocalPlayer:SetAttribute("DeathLocation", deathRoot and deathRoot.Position or Vector3.new(0, 0, 0))
        end, "Death protection error")
        
        -- 延迟重生（防止冲突）
        wait(CONFIG.RESPAWN_DELAY)
        
        -- 强制重生（带错误重试）
        local respawnSuccess = false
        for attempt = 1, CONFIG.FORCE_RESPAWN_ATTEMPTS do
            local success = SafeTools.SafeExecute(function()
                STATE.IsLoading = true
                LocalPlayer:LoadCharacter()
                return true
            end, "Respawn attempt " .. attempt .. " failed")
            
            if success then
                respawnSuccess = true
                break
            end
            
            -- 等待后重试
            wait(0.15)
        end
        
        -- 重生失败处理
        if not respawnSuccess then
            SafeTools.SafeExecute(function()
                LocalPlayer:SetAttribute("RespawnFailed", true)
                
                -- 尝试创建新角色
                local newChar = Instance.new("Model")
                newChar.Name = LocalPlayer.Name
                
                local newHumanoid = Instance.new("Humanoid")
                newHumanoid.Parent = newChar
                
                local newRoot = Instance.new("Part")
                newRoot.Name = "HumanoidRootPart"
                newRoot.Size = Vector3.new(2, 2, 1)
                newRoot.Position = SafeTools.GetRecentPosition()
                newRoot.Parent = newChar
                
                newChar.Parent = Workspace
                
                STATE.Character = newChar
                STATE.Humanoid = newHumanoid
                STATE.HumanoidRootPart = newRoot
                STATE.IsCharacterValid = true
            end, "Emergency character creation failed")
        end
        
        STATE.IsRespawning = false
        STATE.IsDead = false
        STATE.IsLoading = false
        
        -- 更新重生计数
        LocalPlayer:SetAttribute("RespawnCount", STATE.RespawnCount)
    end)
    
    table.insert(STATE.Connections.Respawn, diedConn)
    
    -- 重生位置设置（精确死亡位置）
    local charConn = LocalPlayer.CharacterAdded:Connect(function(newChar)
        if not newChar or STATE.IsLoading then return end
        
        wait(0.3) -- 等待角色完全加载
        
        SafeTools.SafeExecute(function()
            if newChar:IsDescendantOf(Workspace) then
                local newRoot = SafeTools.GetInstance(newChar, "HumanoidRootPart", "BasePart")
                if newRoot then
                    -- 获取死亡位置并重生
                    local respawnPos = SafeTools.GetRecentPosition()
                    newRoot.CFrame = CFrame.new(respawnPos + CONFIG.RESPAWN_POSITION_OFFSET)
                    
                    -- 重置物理状态
                    newRoot.Velocity = Vector3.new(0, 0, 0)
                    newRoot.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    newRoot.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    
                    -- 重生效果
                    local respawnEffect = Instance.new("Explosion")
                    respawnEffect.Position = respawnPos
                    respawnEffect.BlastRadius = 5
                    respawnEffect.BlastPressure = 0
                    respawnEffect.ExplosionType = Enum.ExplosionType.NoCraters
                    respawnEffect.Parent = Workspace
                    
                    DebrisService:AddItem(respawnEffect, 1)
                end
            end
        end, "Respawn position set error")
    end)
    
    table.insert(STATE.Connections.Respawn, charConn)
    
    -- 防止重生失败
    local safetyConn = RunService.Heartbeat:Connect(function()
        if STATE.IsDead and tick() - STATE.LastRespawnTime > 3 then
            STATE.IsDead = false
            SafeTools.SafeExecute(function()
                LocalPlayer:LoadCharacter()
            end, "Safety respawn failed")
        end
    end)
    
    table.insert(STATE.Connections.Respawn, safetyConn)
end

-- ==================== 全维度抓取拦截系统 ====================
local AntiGrabSystem = {}

function AntiGrabSystem.Initialize(character)
    if not character or typeof(character) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.AntiGrab)
    
    local rootPart = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
    if not rootPart then return end
    
    -- 1. 关节连接拦截
    local jointConn = character.DescendantAdded:Connect(function(desc)
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            local isJoint = desc:IsA("WeldConstraint") or desc:IsA("Weld") or 
                           desc:IsA("Motor6D") or desc:IsA("Attachment")
            
            if isJoint then
                local part0 = desc.Part0
                local part1 = desc.Part1
                
                -- 检查是否连接到外部对象
                if part0 and not part0:IsDescendantOf(character) then
                    desc:Destroy()
                    return
                end
                
                if part1 and not part1:IsDescendantOf(character) then
                    desc:Destroy()
                    return
                end
                
                -- 检查异常连接
                if desc:IsA("Motor6D") then
                    local c0 = desc.C0
                    local c1 = desc.C1
                    
                    if c0 and c1 then
                        local distance = (c0.Position - c1.Position).Magnitude
                        if distance > 50 then
                            desc:Destroy()
                        end
                    end
                end
            end
        end, "Joint interception error")
    end)
    
    table.insert(STATE.Connections.AntiGrab, jointConn)
    
    -- 2. 父对象监控
    local parentConn = rootPart:GetPropertyChangedSignal("Parent"):Connect(function()
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            local currentParent = rootPart.Parent
            if currentParent and currentParent ~= character then
                if not currentParent:IsDescendantOf(Workspace) then
                    rootPart.Parent = character
                    
                    -- 反抓取推送
                    local grabber = currentParent:FindFirstChildOfClass("Humanoid")
                    if grabber then
                        local grabberRoot = grabber.Parent:FindFirstChild("HumanoidRootPart")
                        if grabberRoot then
                            local dir = (rootPart.Position - grabberRoot.Position).Unit
                            grabberRoot.Velocity = dir * CONFIG.ANTI_GRAB_PUSH_FORCE * -1
                        end
                    end
                end
            end
        end, "Parent monitor error")
    end)
    
    table.insert(STATE.Connections.AntiGrab, parentConn)
    
    -- 3. 力场检测和拦截
    local forceConn = RunService.Heartbeat:Connect(function()
        if not STATE.IsCharacterValid or not rootPart then return end
        
        SafeTools.SafeExecute(function()
            -- 检测附近力场
            local overlapParams = OverlapParams.new()
            overlapParams.FilterDescendantsInstances = {character}
            overlapParams.FilterType = Enum.RaycastFilterType.Blacklist
            
            local nearby = Workspace:GetPartsInPart(rootPart, CONFIG.GRAB_DETECTION_RADIUS, overlapParams)
            
            for _, part in ipairs(nearby) do
                if part.Parent ~= character then
                    -- 检查力组件
                    local bodyForce = part:FindFirstChildOfClass("BodyForce")
                    local bodyVelocity = part:FindFirstChildOfClass("BodyVelocity")
                    local bodyPosition = part:FindFirstChildOfClass("BodyPosition")
                    local bodyThrust = part:FindFirstChildOfClass("BodyThrust")
                    local bodyAngularVelocity = part:FindFirstChildOfClass("BodyAngularVelocity")
                    
                    -- 检测抓取力
                    if bodyForce and bodyForce.Force.Magnitude > CONFIG.GRAB_FORCE_THRESHOLD then
                        bodyForce:Destroy()
                        
                        -- 推开抓取者
                        if part.Parent:FindFirstChildOfClass("Humanoid") then
                            local dir = (rootPart.Position - part.Position).Unit
                            part.Velocity = dir * CONFIG.ANTI_GRAB_PUSH_FORCE
                        end
                    end
                    
                    if bodyVelocity and bodyVelocity.Velocity.Magnitude > CONFIG.GRAB_FORCE_THRESHOLD then
                        bodyVelocity:Destroy()
                        
                        -- 反击
                        if part.Parent ~= character then
                            part.Velocity = Vector3.new(0, 0, 0)
                        end
                    end
                    
                    if bodyPosition and (bodyPosition.Position - rootPart.Position).Magnitude < 10 then
                        bodyPosition:Destroy()
                    end
                    
                    if bodyThrust and bodyThrust.Force.Magnitude > 5000 then
                        bodyThrust:Destroy()
                    end
                    
                    if bodyAngularVelocity and bodyAngularVelocity.AngularVelocity.Magnitude > 50 then
                        bodyAngularVelocity:Destroy()
                    end
                end
            end
            
            -- 检查自身力组件
            for _, child in ipairs(rootPart:GetChildren()) do
                if child:IsA("BodyForce") or child:IsA("BodyVelocity") or 
                   child:IsA("BodyPosition") or child:IsA("BodyThrust") then
                    if not child:GetAttribute("Protected") then
                        child:Destroy()
                    end
                end
            end
        end, "Force field detection error")
    end)
    
    table.insert(STATE.Connections.AntiGrab, forceConn)
    
    -- 4. 异常速度检测（防拉扯）
    local velocityConn = RunService.Heartbeat:Connect(function()
        if not STATE.IsCharacterValid or not rootPart then return end
        
        SafeTools.SafeExecute(function()
            local speed = rootPart.Velocity.Magnitude
            
            -- 异常高速检测
            if speed > 120 then
                rootPart.Velocity = Vector3.new(0, 0, 0)
                rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                
                -- 位置修正
                if STATE.LastValidCFrame then
                    rootPart.CFrame = STATE.LastValidCFrame
                end
            end
            
            -- 异常旋转检测
            local angularSpeed = rootPart.AssemblyAngularVelocity.Magnitude
            if angularSpeed > 30 then
                rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
            
            -- 更新有效位置
            STATE.LastValidCFrame = rootPart.CFrame
            
            -- 位置锁定（防止拉扯）
            rootPart.Anchored = false
            if speed > 80 then
                rootPart.Anchored = true
                Delay(0.1, function()
                    if rootPart then
                        rootPart.Anchored = false
                    end
                end)
            end
        end, "Velocity detection error")
    end)
    
    table.insert(STATE.Connections.AntiGrab, velocityConn)
    
    -- 5. 抓取尝试检测
    local grabAttemptConn = rootPart.Touched:Connect(function(otherPart)
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            -- 检查是否是抓取尝试
            local otherParent = otherPart.Parent
            if otherParent and otherParent ~= character then
                local otherHumanoid = otherParent:FindFirstChildOfClass("Humanoid")
                if otherHumanoid then
                    -- 检测抓取速度
                    local relativeVelocity = (rootPart.Velocity - otherPart.Velocity).Magnitude
                    if relativeVelocity > 60 then
                        -- 反抓取传送
                        local teleportDir = (rootPart.Position - otherPart.Position).Unit
                        local teleportPos = rootPart.Position + teleportDir * CONFIG.ANTI_GRAB_TELEPORT_DISTANCE
                        
                        rootPart.CFrame = CFrame.new(teleportPos)
                        
                        -- 推开抓取者
                        otherPart.Velocity = teleportDir * CONFIG.ANTI_GRAB_PUSH_FORCE * -1
                    end
                end
            end
        end, "Grab attempt detection error")
    end)
    
    table.insert(STATE.Connections.AntiGrab, grabAttemptConn)
end

-- ==================== 强制拦截死亡后突脸系统 ====================
local AntiWarpSystem = {}

function AntiWarpSystem.Initialize(character)
    if not character or typeof(character) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.AntiWarp)
    
    local rootPart = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
    if not rootPart then return end
    
    local lastPos = rootPart.Position
    local lastTime = tick()
    local warpLock = false
    local warpHistory = {}
    
    -- 突脸检测主循环
    local warpConn = RunService.Heartbeat:Connect(function()
        if not STATE.IsCharacterValid or not rootPart or warpLock then
            return
        end
        
        SafeTools.SafeExecute(function()
            local now = tick()
            local dt = now - lastTime
            
            -- 计算位移和速度
            local currentPos = rootPart.Position
            local delta = (currentPos - lastPos).Magnitude
            local speed = delta / math.max(dt, 0.001)
            
            -- 记录移动历史
            table.insert(warpHistory, {
                Position = currentPos,
                Time = now,
                Speed = speed,
                Delta = delta
            })
            
            while #warpHistory > 10 do
                table.remove(warpHistory, 1)
            end
            
            -- 突脸检测逻辑
            local isWarping = false
            local warpReason = ""
            
            -- 速度检测
            if speed > CONFIG.WARP_SPEED_LIMIT then
                isWarping = true
                warpReason = "Speed limit exceeded: " .. math.floor(speed)
            end
            
            -- 位移检测
            if delta > CONFIG.WARP_DETECTION_THRESHOLD and dt < 0.05 then
                isWarping = true
                warpReason = "Teleport detected: " .. math.floor(delta) .. " studs in " .. math.floor(dt*1000) .. "ms"
            end
            
            -- 历史模式检测
            if #warpHistory >= 3 then
                local recentSpeeds = {}
                for i = math.max(1, #warpHistory-2), #warpHistory do
                    table.insert(recentSpeeds, warpHistory[i].Speed)
                end
                
                local speedVariation = math.max(unpack(recentSpeeds)) - math.min(unpack(recentSpeeds))
                if speedVariation > 80 then
                    isWarping = true
                    warpReason = "Speed variation detected: " .. math.floor(speedVariation)
                end
            end
            
            -- 拦截处理
            if isWarping then
                warpLock = true
                
                -- 记录突脸事件
                LocalPlayer:SetAttribute("LastWarpTime", now)
                LocalPlayer:SetAttribute("WarpReason", warpReason)
                LocalPlayer:SetAttribute("WarpCount", (LocalPlayer:GetAttribute("WarpCount") or 0) + 1)
                
                -- 位置还原
                rootPart.CFrame = CFrame.new(lastPos) + CONFIG.RESPAWN_POSITION_OFFSET
                
                -- 重置物理状态
                rootPart.Velocity = Vector3.new(0, 0, 0)
                rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                rootPart.RotVelocity = Vector3.new(0, 0, 0)
                
                -- 清除力组件
                for _, child in ipairs(rootPart:GetChildren()) do
                    if child:IsA("BodyForce") or child:IsA("BodyVelocity") or 
                       child:IsA("BodyPosition") or child:IsA("BodyThrust") then
                        child:Destroy()
                    end
                end
                
                -- 位置锁定
                rootPart.Anchored = true
                
                -- 反突脸效果
                local antiWarpEffect = Instance.new("Explosion")
                antiWarpEffect.Position = rootPart.Position
                antiWarpEffect.BlastRadius = 8
                antiWarpEffect.BlastPressure = 0
                antiWarpEffect.DestroyJointRadiusPercent = 0
                antiWarpEffect.Parent = Workspace
                
                DebrisService:AddItem(antiWarpEffect, 1)
                
                -- 短暂锁定
                wait(CONFIG.WARP_COOLDOWN)
                
                -- 解锁
                rootPart.Anchored = false
                warpLock = false
                
                -- 清理历史
                warpHistory = {}
            else
                -- 正常移动，更新位置
                lastPos = currentPos
            end
            
            lastTime = now
            
            -- 防突脸保护
            if CONFIG.WARP_TELEPORT_PROTECTION then
                local nearbyPlayers = PlayerService:GetPlayers()
                for _, player in ipairs(nearbyPlayers) do
                    if player ~= LocalPlayer then
                        local otherChar = player.Character
                        if otherChar then
                            local otherRoot = otherChar:FindFirstChild("HumanoidRootPart")
                            if otherRoot then
                                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                                
                                -- 检测突脸攻击
                                if distance < 10 and otherRoot.Velocity.Magnitude > 50 then
                                    -- 推开突脸者
                                    local pushDir = (rootPart.Position - otherRoot.Position).Unit
                                    otherRoot.Velocity = pushDir * 25 * -1
                                    
                                    -- 自身保护位移
                                    rootPart.Velocity = pushDir * 15
                                end
                            end
                        end
                    end
                end
            end
        end, "AntiWarp detection error")
    end)
    
    table.insert(STATE.Connections.AntiWarp, warpConn)
    
    -- 网络延迟检测
    local networkConn = RunService.Heartbeat:Connect(function()
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            -- 检测网络延迟导致的突脸
            local networkStats = stats and stats.Network or nil
            if networkStats then
                local ping = networkStats.ServerStatsItem["Data Ping"]
                if ping and ping > 300 then -- 高延迟
                    -- 位置预测修正
                    if rootPart.Velocity.Magnitude > 30 then
                        local predictedPos = rootPart.Position + rootPart.Velocity * (ping / 1000)
                        rootPart.CFrame = CFrame.new(predictedPos)
                    end
                end
            end
        end, "Network detection error")
    end)
    
    table.insert(STATE.Connections.AntiWarp, networkConn)
end

-- ==================== 强制拦截剧情杀系统 ====================
local AntiScriptedDeathSystem = {}

function AntiScriptedDeathSystem.Initialize(humanoid)
    if not humanoid or typeof(humanoid) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.AntiScriptedDeath)
    
    -- 血量保护监控
    local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            local currentHealth = humanoid.Health
            local maxHealth = humanoid.MaxHealth
            
            -- 防止剧情杀锁血
            if currentHealth <= 0 then
                humanoid.Health = math.max(1, maxHealth * 0.7)
                SafeTools.ForceAlive(humanoid)
                return
            end
            
            -- 防止血量被设为0
            if currentHealth == 0 then
                humanoid.Health = maxHealth * 0.5
            end
            
            -- 防止血量过低
            if currentHealth > 0 and currentHealth < maxHealth * CONFIG.HEALTH_LOCK_THRESHOLD then
                humanoid.Health = maxHealth * 0.5
            end
            
            -- 防止血量被突然清空
            local healthChange = math.abs(currentHealth - (STATE.LastValidHealth or currentHealth))
            if healthChange > maxHealth * 0.8 and healthChange < maxHealth * 0.99 then
                humanoid.Health = maxHealth * 0.6
            end
            
            STATE.LastValidHealth = humanoid.Health
            
            -- 血量变化记录
            humanoid:SetAttribute("LastHealthChange", tick())
            humanoid:SetAttribute("HealthChangeAmount", healthChange)
        end, "Health protection error")
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, healthConn)
    
    -- 死亡事件拦截
    local diedConn = humanoid.Died:Connect(function()
        if STATE.IsCharacterValid then
            SafeTools.SafeExecute(function()
                -- 立即复活
                humanoid.Health = math.max(1, humanoid.MaxHealth * 0.8)
                
                -- 清除死亡标记
                humanoid:SetAttribute("Died", false)
                humanoid:SetAttribute("DeathCause", "ScriptedDeathBlocked")
                
                -- 剧情杀防护通知
                LocalPlayer:SetAttribute("ScriptedDeathBlocked", tick())
            end, "Died event blocking error")
        end
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, diedConn)
    
    -- 最大血量保护
    local maxHealthConn = humanoid:GetPropertyChangedSignal("MaxHealth"):Connect(function()
        SafeTools.SafeExecute(function()
            -- 防止最大血量被设为0或过低
            if humanoid.MaxHealth <= 0 then
                humanoid.MaxHealth = 100
            elseif humanoid.MaxHealth < 80 then
                humanoid.MaxHealth = 120
            end
            
            -- 同步血量
            if humanoid.Health > humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end, "MaxHealth protection error")
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, maxHealthConn)
    
    -- 剧情杀脚本检测和禁用
    local function DisableDeathScripts()
        SafeTools.SafeExecute(function()
            local containers = {
                LocalPlayer.PlayerScripts,
                Workspace,
                ReplicatedStorage,
                StarterPlayer.StarterPlayerScripts,
                StarterGui,
                StarterPack,
                game:GetService("ReplicatedFirst"),
                game:GetService("ServerScriptService"),
                game:GetService("ServerStorage")
            }
            
            for _, container in ipairs(containers) do
                if container and container:IsDescendantOf(game) then
                    for _, child in ipairs(container:GetDescendants()) do
                        if child:IsA("LocalScript") or child:IsA("Script") then
                            local shouldBlock = SafeTools.StringMatch(child.Name, CONFIG.SCRIPTED_DEATH_KEYWORDS)
                            
                            if not shouldBlock and child:IsA("ModuleScript") then
                                local source = child.Source
                                if source and type(source) == "string" then
                                    for _, keyword in ipairs(CONFIG.SCRIPTED_DEATH_KEYWORDS) do
                                        if string.find(source, keyword, 1, true) then
                                            shouldBlock = true
                                            break
                                        end
                                    end
                                end
                            end
                            
                            if shouldBlock and not STATE.BlockedScripts[child] then
                                child.Disabled = true
                                STATE.BlockedScripts[child] = {
                                    Time = tick(),
                                    Name = child.Name,
                                    Parent = child.Parent and child.Parent.Name or "Unknown"
                                }
                                
                                -- 标记为受保护
                                child:SetAttribute("BlockedBySurvivalScript", true)
                            end
                        end
                    end
                end
            end
        end, "DisableDeathScripts error")
    end
    
    -- 初始禁用
    DisableDeathScripts()
    
    -- 定期检查
    local scriptCheckConn = RunService.Heartbeat:Connect(function()
        if tick() % 10 < 0.1 then
            DisableDeathScripts()
        end
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, scriptCheckConn)
    
    -- 监听新脚本
    local scriptConn = Workspace.DescendantAdded:Connect(function(desc)
        if desc:IsA("LocalScript") or desc:IsA("Script") then
            if SafeTools.StringMatch(desc.Name, CONFIG.SCRIPTED_DEATH_KEYWORDS) then
                SafeTools.SafeExecute(function()
                    desc.Disabled = true
                    STATE.BlockedScripts[desc] = {
                        Time = tick(),
                        Name = desc.Name
                    }
                end, "New script blocking error")
            end
        end
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, scriptConn)
    
    -- 剧情杀触发器检测
    local triggerConn = Workspace.DescendantAdded:Connect(function(desc)
        if desc:IsA("BasePart") then
            local triggerNames = {"Death", "Kill", "Trap", "InstantDeath", "ScriptedDeath"}
            
            for _, name in ipairs(triggerNames) do
                if string.find(desc.Name, name, 1, true) then
                    SafeTools.SafeExecute(function()
                        -- 禁用触发器
                        if desc:IsA("BasePart") and desc.CanTouch then
                            desc.CanTouch = false
                        end
                        
                        -- 移除有害脚本
                        for _, script in ipairs(desc:GetDescendants()) do
                            if script:IsA("Script") then
                                script.Disabled = true
                            end
                        end
                    end, "Trigger blocking error")
                    break
                end
            end
        end
    end)
    
    table.insert(STATE.Connections.AntiScriptedDeath, triggerConn)
end

-- ==================== 强制拦截捣毁角色死亡系统 ====================
local AntiDestroySystem = {}

function AntiDestroySystem.Initialize(character)
    if not character or typeof(character) ~= "Instance" then return end
    
    SafeTools.DisconnectAll(STATE.Connections.AntiDestroy)
    
    -- 祖先变化监控（防销毁）
    local destroyConn = character.AncestryChanged:Connect(function(_, parent)
        if not parent and STATE.IsCharacterValid and not STATE.IsRespawning then
            STATE.IsRespawning = true
            
            SafeTools.SafeExecute(function()
                -- 记录销毁位置
                local rootPart = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
                if rootPart then
                    SafeTools.RecordPosition(rootPart.Position)
                end
                
                -- 标记销毁事件
                LocalPlayer:SetAttribute("CharacterDestroyed", tick())
                LocalPlayer:SetAttribute("DestroyLocation", rootPart and rootPart.Position or Vector3.new(0, 0, 0))
                
                -- 延迟重生
                wait(CONFIG.RESPAWN_DELAY)
                
                -- 强制重生
                local success = SafeTools.SafeExecute(function()
                    LocalPlayer:LoadCharacter()
                    return true
                end, "Destroy respawn failed")
                
                if not success then
                    wait(0.5)
                    LocalPlayer:LoadCharacter()
                end
            end, "AncestryChanged handler error")
            
            STATE.IsRespawning = false
        end
    end)
    
    table.insert(STATE.Connections.AntiDestroy, destroyConn)
    
    -- 部件移除保护
    local partConn = character.DescendantRemoving:Connect(function(desc)
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            -- 检查是否是关键部件
            for _, partName in ipairs(CONFIG.CRITICAL_BODY_PARTS) do
                if desc.Name == partName and desc:IsA("BasePart") then
                    -- 记录移除事件
                    LocalPlayer:SetAttribute("PartRemoved", partName)
                    LocalPlayer:SetAttribute("PartRemovalTime", tick())
                    
                    -- 立即创建替代部件
                    local newPart = Instance.new("Part")
                    newPart.Name = desc.Name
                    newPart.Size = desc.Size
                    newPart.CFrame = desc.CFrame
                    newPart.Anchored = false
                    newPart.CanCollide = true
                    newPart.Massless = false
                    newPart.Transparency = 0
                    
                    -- 复制材质和颜色
                    newPart.Material = desc.Material
                    newPart.Color = desc.Color
                    newPart.Reflectance = desc.Reflectance
                    newPart.Transparency = desc.Transparency
                    
                    -- 设置碰撞组
                    if PhysicsService then
                        PhysicsService:SetPartCollisionGroup(newPart, "Character")
                    end
                    
                    newPart.Parent = character
                    
                    -- 重新绑定Humanoid
                    if desc.Name == "HumanoidRootPart" then
                        local humanoid = SafeTools.GetInstance(character, "Humanoid", "Humanoid")
                        if humanoid then
                            humanoid.RootPart = newPart
                        end
                    end
                    
                    -- 重建连接
                    if desc:IsA("BasePart") then
                        for _, weld in ipairs(character:GetDescendants()) do
                            if weld:IsA("Weld") or weld:IsA("WeldConstraint") or weld:IsA("Motor6D") then
                                if weld.Part0 == desc then
                                    weld.Part0 = newPart
                                end
                                if weld.Part1 == desc then
                                    weld.Part1 = newPart
                                end
                            end
                        end
                    end
                    
                    -- 防护效果
                    local protectionEffect = Instance.new("Sparkles")
                    protectionEffect.Color = Color3.fromRGB(0, 255, 0)
                    protectionEffect.SparkleColor = Color3.fromRGB(0, 255, 0)
                    protectionEffect.Parent = newPart
                    
                    DebrisService:AddItem(protectionEffect, 2)
                    
                    break
                end
            end
        end, "Part removal protection error")
    end)
    
    table.insert(STATE.Connections.AntiDestroy, partConn)
    
    -- 完整性检查循环
    local integrityConn = RunService.Heartbeat:Connect(function()
        if not character or not character.Parent then return end
        
        SafeTools.SafeExecute(function()
            -- 检查所有关键部件
            for _, partName in ipairs(CONFIG.CRITICAL_BODY_PARTS) do
                local part = character:FindFirstChild(partName)
                
                if not part or not part:IsA("BasePart") then
                    -- 创建缺失部件
                    local newPart = Instance.new("Part")
                    newPart.Name = partName
                    
                    -- 设置尺寸
                    if partName == "Head" then
                        newPart.Size = Vector3.new(2, 2, 2)
                    elseif partName == "HumanoidRootPart" then
                        newPart.Size = Vector3.new(2, 2, 1)
                    else
                        newPart.Size = Vector3.new(1, 2, 1)
                    end
                    
                    -- 设置位置
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        newPart.CFrame = rootPart.CFrame
                    else
                        newPart.CFrame = CFrame.new(0, 5, 0)
                    end
                    
                    newPart.Anchored = false
                    newPart.CanCollide = true
                    newPart.Massless = false
                    newPart.Transparency = 0
                    newPart.Color = Color3.fromRGB(255, 255, 255)
                    newPart.Parent = character
                    
                    -- 设置Humanoid根部件
                    if partName == "HumanoidRootPart" then
                        local humanoid = SafeTools.GetInstance(character, "Humanoid", "Humanoid")
                        if humanoid then
                            humanoid.RootPart = newPart
                        end
                    end
                    
                    -- 创建连接
                    if rootPart and partName ~= "HumanoidRootPart" then
                        local weld = Instance.new("WeldConstraint")
                        weld.Part0 = rootPart
                        weld.Part1 = newPart
                        weld.Parent = newPart
                    end
                else
                    -- 确保部件属性正确
                    if part.Anchored then
                        part.Anchored = false
                    end
                    
                    if part.Massless then
                        part.Massless = false
                    end
                    
                    -- 防止部件被移出Workspace
                    if not part:IsDescendantOf(Workspace) then
                        part.Parent = Workspace
                        wait(0.05)
                        part.Parent = character
                    end
                end
            end
            
            -- 检查Humanoid状态
            local humanoid = SafeTools.GetInstance(character, "Humanoid", "Humanoid")
            if humanoid then
                -- 确保Humanoid有根部件
                if not humanoid.RootPart or not humanoid.RootPart:IsDescendantOf(character) then
                    local rootPart = character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        humanoid.RootPart = rootPart
                    end
                end
                
                -- 防止Humanoid被禁用
                if humanoid:GetAttribute("Disabled") then
                    humanoid:SetAttribute("Disabled", false)
                end
            end
        end, "Integrity check error")
    end)
    
    table.insert(STATE.Connections.AntiDestroy, integrityConn)
    
    -- 部件位置锁定
    local positionLockConn = RunService.Heartbeat:Connect(function()
        if not STATE.IsCharacterValid then return end
        
        SafeTools.SafeExecute(function()
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                -- 防止部件分离
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") and part ~= rootPart then
                        local distance = (part.Position - rootPart.Position).Magnitude
                        
                        if distance > 20 then -- 部件分离检测
                            part.CFrame = rootPart.CFrame
                            part.Velocity = Vector3.new(0, 0, 0)
                        end
                    end
                end
            end
        end, "Position lock error")
    end)
    
    table.insert(STATE.Connections.AntiDestroy, positionLockConn)
end

-- ==================== 强制拦截远程指令死亡系统 ====================
local RemoteBlockSystem = {}

function RemoteBlockSystem.Initialize()
    SafeTools.DisconnectAll(STATE.Connections.RemoteBlock)
    
    -- 安全远程拦截函数
    local function SafeBlockRemote(remote, player)
        if not remote or not player or STATE.BlockedRemotes[remote] then
            return false
        end
        
        -- 检查远程名称
        local shouldBlock = SafeTools.StringMatch(remote.Name, CONFIG.REMOTE_BLOCK_KEYWORDS)
        
        if shouldBlock then
            SafeTools.SafeExecute(function()
                -- 标记为已拦截
                STATE.BlockedRemotes[remote] = {
                    Time = tick(),
                    Name = remote.Name,
                    Class = remote.ClassName,
                    Path = remote:GetFullName()
                }
                
                -- 设置防护标记
                remote:SetAttribute("BlockedBySurvivalScript", true)
                remote:SetAttribute("BlockTime", tick())
                
                -- 对于RemoteEvent，拦截事件
                if remote:IsA("RemoteEvent") then
                    -- 保存原始连接
                    local originalEvent = remote.OnClientEvent
                    
                    -- 设置安全的事件处理器
                    remote.OnClientEvent = function(...)
                        local args = {...}
                        local shouldAllow = true
                        
                        -- 检查参数中是否有危险指令
                        for _, arg in ipairs(args) do
                            if type(arg) == "string" then
                                if SafeTools.StringMatch(arg, {"kill", "death", "destroy", "damage"}) then
                                    shouldAllow = false
                                    break
                                end
                            elseif arg == LocalPlayer then
                                -- 针对玩家的指令拦截
                                shouldAllow = false
                                break
                            end
                        end
                        
                        if not shouldAllow then
                            -- 拦截危险指令
                            if STATE.Humanoid then
                                SafeTools.ForceAlive(STATE.Humanoid)
                            end
                            return nil
                        end
                        
                        -- 安全执行
                        return SafeTools.SafeCall(originalEvent, ...)
                    end
                end
                
                -- 对于RemoteFunction，拦截调用
                if remote:IsA("RemoteFunction") then
                    local originalInvoke = remote.InvokeClient
                    
                    if originalInvoke then
                        remote.InvokeClient = function(...)
                            local args = {...}
                            local shouldAllow = true
                            
                            -- 检查参数
                            for _, arg in ipairs(args) do
                                if type(arg) == "string" then
                                    if SafeTools.StringMatch(arg, {"kill", "death", "destroy"}) then
                                        shouldAllow = false
                                        break
                                    end
                                elseif arg == LocalPlayer then
                                    shouldAllow = false
                                    break
                                end
                            end
                            
                            if not shouldAllow then
                                -- 拦截并返回安全值
                                if STATE.Humanoid then
                                    SafeTools.ForceAlive(STATE.Humanoid)
                                end
                                return nil
                            end
                            
                            -- 安全调用
                            return SafeTools.SafeCall(originalInvoke, ...)
                        end
                    end
                end
                
                return true
            end, "SafeBlockRemote error for " .. (remote.Name or "Unknown"))
            
            return true
        end
        
        return false
    end
    
    -- 扫描远程对象
    local function ScanForRemotes()
        SafeTools.SafeExecute(function()
            local containers = {
                ReplicatedStorage,
                Workspace,
                StarterPack,
                StarterGui,
                LocalPlayer.PlayerScripts,
                LocalPlayer.Backpack,
                game:GetService("ReplicatedFirst"),
                game:GetService("ServerScriptService"),
                game:GetService("ServerStorage")
            }
            
            for _, container in ipairs(containers) do
                if container and container:IsDescendantOf(game) then
                    for _, child in ipairs(container:GetDescendants()) do
                        if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) then
                            if not STATE.BlockedRemotes[child] then
                                SafeBlockRemote(child, LocalPlayer)
                            else
                                -- 重新检查已拦截的远程
                                local blockedInfo = STATE.BlockedRemotes[child]
                                if blockedInfo and tick() - blockedInfo.Time > 300 then -- 5分钟后重新检查
                                    STATE.BlockedRemotes[child] = nil
                                    SafeBlockRemote(child, LocalPlayer)
                                end
                            end
                        end
                    end
                end
            end
        end, "ScanForRemotes error")
    end
    
    -- 初始扫描
    ScanForRemotes()
    
    -- 监听新远程对象
    local remoteConn = ReplicatedStorage.DescendantAdded:Connect(function(desc)
        if (desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction")) then
            wait(CONFIG.REMOTE_DETECTION_DELAY)
            SafeTools.SafeExecute(function()
                SafeBlockRemote(desc, LocalPlayer)
            end, "New remote blocking error")
        end
    end)
    
    table.insert(STATE.Connections.RemoteBlock, remoteConn)
    
    -- Workspace远程监听
    local workspaceConn = Workspace.DescendantAdded:Connect(function(desc)
        if (desc:IsA("RemoteEvent") or desc:IsA("RemoteFunction")) then
            wait(0.2)
            SafeTools.SafeExecute(function()
                SafeBlockRemote(desc, LocalPlayer)
            end, "Workspace remote blocking error")
        end
    end)
    
    table.insert(STATE.Connections.RemoteBlock, workspaceConn)
    
    -- 定期扫描
    local scanConn = RunService.Heartbeat:Connect(function()
        if tick() % 15 < 0.1 then
            ScanForRemotes()
        end
    end)
    
    table.insert(STATE.Connections.RemoteBlock, scanConn)
    
    -- 强制拦截模式
    if CONFIG.REMOTE_FORCE_BLOCK then
        local forceBlockConn = RunService.Heartbeat:Connect(function()
            SafeTools.SafeExecute(function()
                -- 强制拦截所有可能的危险远程
                local allRemotes = {}
                
                local function collectRemotes(parent)
                    for _, child in ipairs(parent:GetChildren()) do
                        if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                            table.insert(allRemotes, child)
                        end
                        collectRemotes(child)
                    end
                end
                
                collectRemotes(game)
                
                for _, remote in ipairs(allRemotes) do
                    if not STATE.BlockedRemotes[remote] then
                        SafeBlockRemote(remote, LocalPlayer)
                    end
                end
            end, "Force block error")
        end)
        
        table.insert(STATE.Connections.RemoteBlock, forceBlockConn)
    end
end

-- ==================== 强制破解一命重生系统 ====================
local InfiniteLivesSystem = {}

function InfiniteLivesSystem.Initialize()
    -- 破解一命限制
    SafeTools.SafeExecute(function()
        -- 玩家属性破解
        LocalPlayer:SetAttribute("Lives", math.huge)
        LocalPlayer:SetAttribute("MaxLives", math.huge)
        LocalPlayer:SetAttribute("RemainingLives", math.huge)
        LocalPlayer:SetAttribute("OneLifeMode", false)
        LocalPlayer:SetAttribute("LimitedLives", false)
        LocalPlayer:SetAttribute("InfiniteLives", true)
        LocalPlayer:SetAttribute("CanAlwaysRespawn", true)
        LocalPlayer:SetAttribute("RespawnPenalty", 0)
        
        -- 游戏服务破解
        local gameStats = game:GetService("Stats")
        if gameStats then
            gameStats:SetAttribute("PlayerLives", math.huge)
        end
        
        -- 破解重生服务
        local respawnServices = {
            ReplicatedStorage:FindFirstChild("RespawnService"),
            Workspace:FindFirstChild("RespawnController"),
            game:GetService("ReplicatedFirst"):FindFirstChild("LifeSystem")
        }
        
        for _, service in ipairs(respawnServices) do
            if service then
                service:SetAttribute("MaxLives", math.huge)
                service:SetAttribute("CurrentLives", math.huge)
                service:SetAttribute("OneLife", false)
                service:SetAttribute("LifeLimit", false)
                
                -- 禁用生命减少脚本
                for _, script in ipairs(service:GetDescendants()) do
                    if script:IsA("Script") then
                        local src = script.Source
                        if src and (string.find(src, "Lives", 1, true) or 
                                   string.find(src, "Life", 1, true) or
                                   string.find(src, "RespawnLimit", 1, true)) then
                            script.Disabled = true
                        end
                    end
                end
            end
        end
    end, "Infinite lives initialization error")
    
    -- 生命监控
    local lifeMonitor = RunService.Heartbeat:Connect(function()
        SafeTools.SafeExecute(function()
            -- 确保无限生命
            LocalPlayer:SetAttribute("Lives", math.huge)
            
            -- 破解生命UI
            local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
            if playerGui then
                for _, gui in ipairs(playerGui:GetChildren()) do
                    if gui:IsA("ScreenGui") then
                        local lifeText = gui:FindFirstChild("LivesText") or 
                                        gui:FindFirstChild("LifeText") or
                                        gui:FindFirstChild("LifeCounter")
                        
                        if lifeText and lifeText:IsA("TextLabel") then
                            lifeText.Text = "∞ Lives"
                        end
                    end
                end
            end
            
            -- 防止生命减少
            if LocalPlayer:GetAttribute("Lives") and LocalPlayer:GetAttribute("Lives") < 100 then
                LocalPlayer:SetAttribute("Lives", math.huge)
            end
        end, "Life monitor error")
    end)
    
    table.insert(STATE.Connections.Respawn, lifeMonitor)
end

-- ==================== 强制破解观战系统 ====================
local SpectatorBypassSystem = {}

function SpectatorBypassSystem.Initialize()
    -- 禁用观战UI
    local function DisableSpectatorUI()
        SafeTools.SafeExecute(function()
            local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
            if playerGui then
                for _, gui in ipairs(playerGui:GetChildren()) do
                    if gui:IsA("ScreenGui") then
                        local shouldDisable = SafeTools.StringMatch(gui.Name, CONFIG.SPECTATOR_KEYWORDS)
                        
                        if not shouldDisable then
                            -- 检查子对象
                            for _, child in ipairs(gui:GetDescendants()) do
                                if child:IsA("TextLabel") or child:IsA("TextButton") then
                                    local text = child.Text
                                    if text and type(text) == "string" then
                                        if SafeTools.StringMatch(text, CONFIG.SPECTATOR_KEYWORDS) then
                                            shouldDisable = true
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        
                        if shouldDisable then
                            gui.Enabled = false
                            gui:SetAttribute("DisabledBySurvival", true)
                        end
                    end
                end
            end
        end, "DisableSpectatorUI error")
    end
    
    -- 禁用观战脚本
    local function DisableSpectatorScripts()
        SafeTools.SafeExecute(function()
            local containers = {
                LocalPlayer.PlayerScripts,
                Workspace,
                ReplicatedStorage,
                game:GetService("ReplicatedFirst"),
                game:GetService("ServerScriptService")
            }
            
            for _, container in ipairs(containers) do
                if container then
                    for _, script in ipairs(container:GetDescendants()) do
                        if script:IsA("LocalScript") or script:IsA("Script") then
                            if SafeTools.StringMatch(script.Name, CONFIG.SPECTATOR_KEYWORDS) then
                                script.Disabled = true
                                script:SetAttribute("DisabledBySurvival", true)
                            else
                                -- 检查源代码
                                local source = script.Source
                                if source and type(source) == "string" then
                                    for _, keyword in ipairs(CONFIG.SPECTATOR_KEYWORDS) do
                                        if string.find(source, keyword, 1, true) then
                                            script.Disabled = true
                                            script:SetAttribute("DisabledBySurvival", true)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end, "DisableSpectatorScripts error")
    end
    
    -- 破解观战状态
    local function BypassSpectator()
        SafeTools.SafeExecute(function()
            -- 清除观战属性
            LocalPlayer:SetAttribute("Spectating", false)
            LocalPlayer:SetAttribute("InSpectatorMode", false)
            LocalPlayer:SetAttribute("IsObserver", false)
            LocalPlayer:SetAttribute("IsDead", false)
            LocalPlayer:SetAttribute("CameraMode", "Follow")
            
            -- 强制相机控制
            local camera = Workspace.CurrentCamera
            if camera then
                camera.CameraType = Enum.CameraType.Custom
                camera.CameraSubject = nil
                
                -- 确保相机跟随角色
                if LocalPlayer.Character then
                    local humanoid = SafeTools.GetInstance(LocalPlayer.Character, "Humanoid", "Humanoid")
                    if humanoid then
                        camera.CameraSubject = humanoid
                    end
                end
                
                -- 防止相机锁定
                if camera:GetAttribute("Locked") then
                    camera:SetAttribute("Locked", false)
                end
            end
            
            -- 破解观战服务
            local spectatorServices = {
                Workspace:FindFirstChild("SpectatorService"),
                ReplicatedStorage:FindFirstChild("SpectatorController"),
                game:GetService("ReplicatedFirst"):FindFirstChild("CameraSystem")
            }
            
            for _, service in ipairs(spectatorServices) do
                if service then
                    service:SetAttribute("IsSpectating", false)
                    service:SetAttribute("SpectatorTarget", nil)
                    
                    -- 禁用观战功能
                    for _, script in ipairs(service:GetDescendants()) do
                        if script:IsA("Script") then
                            script.Disabled = true
                        end
                    end
                end
            end
        end, "BypassSpectator error")
    end
    
    -- 初始执行
    DisableSpectatorUI()
    DisableSpectatorScripts()
    BypassSpectator()
    
    -- 定期检查
    local checkConn = RunService.Heartbeat:Connect(function()
        BypassSpectator()
        
        if tick() % 5 < 0.1 then
            DisableSpectatorUI()
        end
        
        if tick() % 10 < 0.1 then
            DisableSpectatorScripts()
        end
    end)
    
    table.insert(STATE.Connections.Monitor, checkConn)
    
    -- 相机强制控制
    if CONFIG.CAMERA_CONTROL_ENFORCE then
        local cameraConn = RunService.RenderStepped:Connect(function()
            SafeTools.SafeExecute(function()
                local camera = Workspace.CurrentCamera
                if camera then
                    -- 确保相机类型正确
                    if camera.CameraType ~= Enum.CameraType.Custom then
                        camera.CameraType = Enum.CameraType.Custom
                    end
                    
                    -- 确保相机跟随角色
                    if not camera.CameraSubject then
                        if LocalPlayer.Character then
                            local humanoid = SafeTools.GetInstance(LocalPlayer.Character, "Humanoid", "Humanoid")
                            if humanoid then
                                camera.CameraSubject = humanoid
                            end
                        end
                    end
                    
                    -- 防止第三方相机控制
                    camera:SetAttribute("ExternalControl", false)
                end
            end, "Camera control error")
        end)
        
        table.insert(STATE.Connections.Monitor, cameraConn)
    end
end

-- ==================== 错误处理系统 ====================
local ErrorHandler = {}

function ErrorHandler.Initialize()
    -- 脚本错误处理
    local scriptErrorConn = ScriptContext.Error:Connect(function(message, stackTrace)
        STATE.ErrorCount = STATE.ErrorCount + 1
        
        SafeTools.SafeExecute(function()
            -- 记录错误
            table.insert(STATE.ErrorLog, {
                Time = tick(),
                Message = message,
                StackTrace = stackTrace,
                Type = "ScriptError"
            })
            
            -- 限制错误日志大小
            while #STATE.ErrorLog > 50 do
                table.remove(STATE.ErrorLog, 1)
            end
            
            -- 检查是否是角色相关错误
            if string.find(message, "PlayerGui") or 
               string.find(message, "Inventory") or
               string.find(message, "LocalScript") then
                -- 忽略UI错误
                return
            end
            
            -- 严重错误恢复
            if string.find(message, "attempt to index nil") or
               string.find(message, "Humanoid") or
               string.find(message, "Character") then
                
                wait(1)
                
                -- 尝试恢复角色
                if STATE.Character and STATE.Character:IsDescendantOf(Workspace) then
                    -- 重新初始化
                    local char = STATE.Character
                    local humanoid = SafeTools.GetInstance(char, "Humanoid", "Humanoid")
                    
                    if humanoid then
                        SafeTools.ForceAlive(humanoid)
                    end
                else
                    -- 强制重生
                    SafeTools.SafeExecute(function()
                        LocalPlayer:LoadCharacter()
                    end, "Error recovery respawn failed")
                end
            end
        end, "Error handler error")
    end)
    
    table.insert(STATE.Connections.ErrorHandler, scriptErrorConn)
    
    -- 连接错误处理
    local connectionMonitor = RunService.Heartbeat:Connect(function()
        -- 清理无效连接
        for category, connections in pairs(STATE.Connections) do
            if type(connections) == "table" then
                for i = #connections, 1, -1 do
                    local conn = connections[i]
                    if conn and typeof(conn) == "RBXScriptConnection" then
                        if not conn.Connected then
                            table.remove(connections, i)
                        end
                    else
                        table.remove(connections, i)
                    end
                end
            end
        end
        
        -- 统计连接数
        STATE.ConnectionCount = 0
        for _, connections in pairs(STATE.Connections) do
            if type(connections) == "table" then
                STATE.ConnectionCount = STATE.ConnectionCount + #connections
            end
        end
        
        -- 内存清理
        if tick() - STATE.LastCleanupTime > CONFIG.CONNECTION_CLEANUP_INTERVAL then
            STATE.LastCleanupTime = tick()
            
            -- 清理旧数据
            for i = #STATE.DeathPositions, 1, -1 do
                if tick() - STATE.DeathPositions[i].Time > 300 then -- 5分钟
                    table.remove(STATE.DeathPositions, i)
                end
            end
            
            -- 清理错误日志
            for i = #STATE.ErrorLog, 1, -1 do
                if tick() - STATE.ErrorLog[i].Time > 600 then -- 10分钟
                    table.remove(STATE.ErrorLog, i)
                end
            end
            
            -- 垃圾回收提示
            if STATE.ConnectionCount > 100 then
                local success = SafeTools.SafeExecute(function()
                    collectgarbage("collect")
                    return true
                end)
            end
        end
    end)
    
    table.insert(STATE.Connections.ErrorHandler, connectionMonitor)
end

-- ==================== 角色初始化系统 ====================
local function InitializeCharacter(character)
    if not character or not character:IsDescendantOf(Workspace) then
        return
    end
    
    -- 等待组件加载
    local humanoid, rootPart
    local startTime = tick()
    local maxWaitTime = 15 -- 最长等待15秒
    
    while tick() - startTime < maxWaitTime do
        humanoid = SafeTools.GetInstance(character, "Humanoid", "Humanoid")
        rootPart = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
        
        if humanoid and rootPart then
            break
        end
        
        -- 渐进式等待
        local waitTime = math.min(0.5, (tick() - startTime) * 0.1)
        wait(waitTime)
    end
    
    if not humanoid or not rootPart then
        -- 组件加载失败，强制创建
        SafeTools.SafeExecute(function()
            if not humanoid then
                humanoid = Instance.new("Humanoid")
                humanoid.Parent = character
            end
            
            if not rootPart then
                rootPart = Instance.new("Part")
                rootPart.Name = "HumanoidRootPart"
                rootPart.Size = Vector3.new(2, 2, 1)
                rootPart.Position = Vector3.new(0, 50, 0)
                rootPart.Anchored = false
                rootPart.CanCollide = true
                rootPart.Parent = character
                
                humanoid.RootPart = rootPart
            end
        end, "Emergency component creation failed")
    end
    
    -- 更新状态
    STATE.Character = character
    STATE.Humanoid = humanoid
    STATE.HumanoidRootPart = rootPart
    STATE.IsCharacterValid = true
    STATE.IsDead = false
    STATE.IsRespawning = false
    STATE.LastValidCFrame = rootPart.CFrame
    
    -- 设置角色属性
    SafeTools.SafeExecute(function()
        character:SetAttribute("SurvivalScriptProtected", true)
        character:SetAttribute("ProtectionTime", tick())
        
        humanoid:SetAttribute("HealthProtected", true)
        humanoid:SetAttribute("MaxHealthLocked", true)
        
        rootPart:SetAttribute("PositionProtected", true)
        rootPart:SetAttribute("VelocityProtected", true)
    end, "Character attribute setting failed")
    
    -- 初始化所有系统
    HealSystem.Initialize(humanoid)
    AntiGrabSystem.Initialize(character)
    AntiWarpSystem.Initialize(character)
    AntiScriptedDeathSystem.Initialize(humanoid)
    AntiDestroySystem.Initialize(character)
    RemoteBlockSystem.Initialize()
    RespawnSystem.Initialize(character)
    InfiniteLivesSystem.Initialize()
    SpectatorBypassSystem.Initialize()
    ErrorHandler.Initialize()
    
    -- 角色强化
    SafeTools.SafeExecute(function()
        -- 生命值强化
        humanoid.MaxHealth = math.max(150, humanoid.MaxHealth * 2)
        humanoid.Health = humanoid.MaxHealth
        
        -- 移动强化
        humanoid.WalkSpeed = math.min(40, humanoid.WalkSpeed * 1.4)
        humanoid.JumpPower = math.min(85, humanoid.JumpPower * 1.3)
        
        -- 其他强化
        humanoid.AutoRotate = true
        humanoid.AutoJumpEnabled = true
        humanoid.BreakJointsOnDeath = false
        humanoid.RequiresNeck = false
        
        -- 设置碰撞组
        if PhysicsService then
            for _, part in ipairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    PhysicsService:SetPartCollisionGroup(part, "Character")
                end
            end
        end
    end, "Character enhancement failed")
    
    -- 角色监控主循环
    local monitorConn = RunService.Heartbeat:Connect(function()
        if not character or not character:IsDescendantOf(Workspace) then
            STATE.IsCharacterValid = false
            
            SafeTools.SafeExecute(function()
                -- 记录最后位置
                local lastRoot = SafeTools.GetInstance(character, "HumanoidRootPart", "BasePart")
                if lastRoot then
                    SafeTools.RecordPosition(lastRoot.Position)
                end
                
                -- 延迟后重生
                wait(0.5)
                LocalPlayer:LoadCharacter()
            end, "Character monitor respawn failed")
            
            SafeTools.Disconnect(monitorConn)
            return
        end
        
        -- 检查生命值
        if humanoid and humanoid.Health <= 0 then
            SafeTools.ForceAlive(humanoid)
        end
        
        -- 更新位置
        if rootPart then
            STATE.LastValidCFrame = rootPart.CFrame
        end
        
        -- 定期状态检查
        local currentTime = tick()
        if currentTime % 5 < 0.1 then
            -- 检查部件完整性
            local partCount = 0
            for _, partName in ipairs(CONFIG.CRITICAL_BODY_PARTS) do
                if character:FindFirstChild(partName) then
                    partCount = partCount + 1
                end
            end
            
            if partCount < #CONFIG.CRITICAL_BODY_PARTS * 0.7 then
                -- 部件缺失过多，重生
                SafeTools.SafeExecute(function()
                    LocalPlayer:LoadCharacter()
                end, "Integrity check respawn failed")
            end
        end
    end)
    
    table.insert(STATE.Connections.Monitor, monitorConn)
    
    -- 角色加载完成标记
    Delay(2, function()
        SafeTools.SafeExecute(function()
            LocalPlayer:SetAttribute("CharacterFullyLoaded", true)
            LocalPlayer:SetAttribute("LoadTime", tick())
        end)
    end)
end

-- ==================== 全局初始化 ====================
local function GlobalInitialize()
    if STATE.IsInitialized then return end
    
    print("[初始化] 手机端超强生存脚本开始加载...")
    print("[版本] 5.0 - 终极修复版")
    print("[目标] 修复所有死亡报错问题")
    
    -- 清理旧状态
    for _, connections in pairs(STATE.Connections) do
        SafeTools.DisconnectAll(connections)
    end
    
    -- 重置状态
    STATE.BlockedRemotes = {}
    STATE.BlockedScripts = {}
    STATE.ProtectedInstances = {}
    STATE.ErrorLog = {}
    STATE.DeathPositions = {}
    STATE.ErrorCount = 0
    STATE.RespawnCount = 0
    
    -- 等待玩家
    if not LocalPlayer then
        repeat 
            wait(0.5)
        until PlayerService.LocalPlayer
        LocalPlayer = PlayerService.LocalPlayer
    end
    
    -- 玩家安全检查
    SafeTools.SafeExecute(function()
        if not LocalPlayer:IsDescendantOf(PlayerService) then
            error("玩家安全检查失败")
        end
    end, "Player security check failed")
    
    -- 绑定角色事件
    local charConn = LocalPlayer.CharacterAdded:Connect(function(char)
        if STATE.IsLoading then return end
        
        STATE.IsLoading = true
        wait(0.8) -- 等待角色完全加载
        
        local success = SafeTools.SafeExecute(function()
            InitializeCharacter(char)
        end, "CharacterAdded handler failed")
        
        STATE.IsLoading = false
        
        if not success then
            wait(1)
            LocalPlayer:LoadCharacter()
        end
    end)
    
    table.insert(STATE.Connections.Utility, charConn)
    
    -- 角色移除事件
    local charRemoving = LocalPlayer.CharacterRemoving:Connect(function(char)
        if char == STATE.Character then
            STATE.IsCharacterValid = false
            
            -- 记录最后位置
            local rootPart = SafeTools.GetInstance(char, "HumanoidRootPart", "BasePart")
            if rootPart then
                SafeTools.RecordPosition(rootPart.Position)
            end
        end
    end)
    
    table.insert(STATE.Connections.Utility, charRemoving)
    
    -- 处理现有角色
    if LocalPlayer.Character then
        wait(1.5)
        InitializeCharacter(LocalPlayer.Character)
    else
        wait(2)
        SafeTools.SafeExecute(function()
            LocalPlayer:LoadCharacter()
        end, "Initial character load failed")
    end
    
    -- 手机优化
    if CONFIG.MOBILE_OPTIMIZATION then
        SafeTools.SafeExecute(function()
            -- 图形优化
            settings().Rendering.QualityLevel = 1
            settings().Rendering.EagerBulkExecution = false
            
            -- 照明优化
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 1000
            Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
            
            -- 物理优化
            settings().Physics.PhysicsEnvironmentalThrottle = 2
            settings().Physics.DeterministicInterpolation = false
            
            -- 网络优化
            settings().Network.PhysicsSend = 1
            settings().Network.IncomingReplicationLag = 0
            
            -- 声音优化
            SoundService:SetAttribute("MobileOptimized", true)
            
            print("[优化] 手机端优化已应用")
        end, "Mobile optimization failed")
    end
    
    -- 错误恢复系统
    local errorRecoveryConn = RunService.Heartbeat:Connect(function()
        if STATE.ErrorCount > 10 then
            STATE.ErrorCount = 0
            
            SafeTools.SafeExecute(function()
                print("[恢复] 检测到多个错误，正在恢复...")
                
                -- 清理所有连接
                for _, connections in pairs(STATE.Connections) do
                    SafeTools.DisconnectAll(connections)
                end
                
                -- 重新初始化
                STATE.IsInitialized = false
                wait(1)
                GlobalInitialize()
            end, "Error recovery failed")
        end
    end)
    
    table.insert(STATE.Connections.ErrorHandler, errorRecoveryConn)
    
    STATE.IsInitialized = true
    
    -- 完成提示
    Delay(4, function()
        print("\n" .. string.rep("=", 70))
        print("📱 手机端通用超强生存脚本 - 终极修复版")
        print(string.rep("-", 70))
        print("🔥 核心功能（已修复所有报错）:")
        print("   ✅ 9倍自动回血系统 - 紧急状态额外加速")
        print("   ✅ 死亡位置无限重生 - 精准位置还原")
        print("   ✅ 全维度抓取拦截 - 5重防御机制")
        print("   ✅ 强制拦截死亡突脸 - 位置锁定保护")
        print("   ✅ 剧情杀100%拦截 - 安全属性监控")
        print("   ✅ 角色防销毁系统 - 核心部件自动修复")
        print("   ✅ 远程指令拦截 - 关键词智能匹配")
        print("   ✅ 强制破解一命重生 - 无限生命")
        print("   ✅ 强制破解观战系统 - 相机控制")
        print(string.rep("-", 70))
        print("⚡ 高级特性:")
        print("   • 完全修复死亡报错问题")
        print("   • 手机触摸回血支持")
        print("   • 全局错误自动恢复")
        print("   • 内存和连接智能管理")
        print("   • 部件完整性检查")
        print("   • 网络延迟优化")
        print("   • 全Roblox游戏通用适配")
        print(string.rep("=", 70))
        print("📊 状态监控:")
        print("   连接数: " .. STATE.ConnectionCount)
        print("   错误数: " .. STATE.ErrorCount)
        print("   重生数: " .. STATE.RespawnCount)
        print("   位置记录: " .. #STATE.DeathPositions)
        print(string.rep("=", 70))
    end)
end

-- ==================== 启动脚本 ====================
-- 使用协程启动，防止阻塞
coroutine.wrap(function()
    -- 等待游戏加载
    local startWait = tick()
    
    while tick() - startWait < 30 do -- 最长等待30秒
        local gameLoaded = SafeTools.SafeExecute(function()
            return game:IsLoaded()
        end)
        
        if gameLoaded then
            break
        end
        
        wait(0.5)
    end
    
    -- 额外安全等待
    wait(2)
    
    -- 检查游戏状态
    local gameValid = SafeTools.SafeExecute(function()
        return game:GetService("Workspace") ~= nil and 
               game:GetService("Players") ~= nil and
               game:GetService("ReplicatedStorage") ~= nil
    end)
    
    if not gameValid then
        warn("[警告] 游戏服务未完全加载，等待中...")
        repeat wait(1) until gameValid
    end
    
    -- 执行初始化
    local initSuccess, initError = SafeTools.SafeExecute(GlobalInitialize)
    
    if not initSuccess then
        warn("[错误] 初始化失败: " .. tostring(initError))
        
        -- 重试初始化
        wait(3)
        GlobalInitialize()
    end
end)()

-- ==================== 脚本接口 ====================
return {
    Version = "5.0",
    Author = "手机端生存专家",
    Description = "终极修复版 - 修复所有死亡报错问题",
    
    Status = function()
        return {
            Initialized = STATE.IsInitialized,
            CharacterValid = STATE.IsCharacterValid,
            Health = STATE.Humanoid and STATE.Humanoid.Health or 0,
            MaxHealth = STATE.Humanoid and STATE.Humanoid.MaxHealth or 0,
            DeathPositions = #STATE.DeathPositions,
            BlockedRemotes = #STATE.BlockedRemotes,
            BlockedScripts = #STATE.BlockedScripts,
            ErrorCount = STATE.ErrorCount,
            RespawnCount = STATE.RespawnCount,
            ConnectionCount = STATE.ConnectionCount
        }
    end,
    
    Reinitialize = function()
        STATE.IsInitialized = false
        GlobalInitialize()
        return "重新初始化完成"
    end,
    
    ForceRespawn = function()
        if STATE.Character then
            local rootPart = SafeTools.GetInstance(STATE.Character, "HumanoidRootPart", "BasePart")
            if rootPart then
                SafeTools.RecordPosition(rootPart.Position)
            end
        end
        
        SafeTools.SafeExecute(function()
            LocalPlayer:LoadCharacter()
        end)
        
        return "强制重生已执行"
    end,
    
    GetConfig = function()
        return CONFIG
    end,
    
    GetErrors = function()
        return STATE.ErrorLog
    end,
    
    ClearErrors = function()
        STATE.ErrorLog = {}
        STATE.ErrorCount = 0
        return "错误日志已清除"
    end,
    
    GetDeathPositions = function()
        return STATE.DeathPositions
    end,
    
    TeleportToRecentDeath = function()
        if #STATE.DeathPositions > 0 then
            local lastPos = STATE.DeathPositions[#STATE.DeathPositions].Position
            if STATE.Character then
                local rootPart = SafeTools.GetInstance(STATE.Character, "HumanoidRootPart", "BasePart")
                if rootPart then
                    rootPart.CFrame = CFrame.new(lastPos + Vector3.new(0, 5, 0))
                    return "已传送到最近死亡位置"
                end
            end
        end
        return "无死亡位置记录"
    end,
    
    EnableGodMode = function()
        if STATE.Humanoid then
            SafeTools.SafeExecute(function()
                STATE.Humanoid.MaxHealth = math.huge
                STATE.Humanoid.Health = math.huge
            end)
            return "无敌模式已启用"
        end
        return "无敌模式启用失败"
    end,
    
    DisconnectAll = function()
        for _, connections in pairs(STATE.Connections) do
            SafeTools.DisconnectAll(connections)
        end
        return "所有连接已断开"
    end
}
]])()